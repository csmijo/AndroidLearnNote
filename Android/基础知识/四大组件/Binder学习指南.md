# Binder 学习指南（笔记）

`Android` `Binder`

---

## 1. 内核模块/驱动

1. `Linux Kernel`是操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。
2. 把`Kernel`和上层的应用程序抽像的隔离开，分别称之为`Kernel Space`和`User Space`。
3. 用户空间访问内核空间的唯一方式就是**系统调用**。
4. 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于**内核运行态（或简称为内核态）**此时处理器处于**特权级最高的（0级）**内核代码中执行。当进程在执行用户自己的代码时，则称其处于**用户运行态（用户态）**。即此时处理器在**特权级最低的（3级）**用户代码中运行。**处理器在特权等级高的时候才能执行那些特权CPU指令**。
5. Binder并不是Linux内核的一部分，它是怎么做到访问内核空间的呢？Linux的**动态可加载内核模块（Loadable Kernel Module，LKM）机制**解决了这个问题。Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。在Android系统中，这个运行在内核空间的，负责各个用户进程通过Binder通信的内核模块叫做**Binder驱动**。

## 2. Binder 通信模型

1. Android使用的Linux内核拥有着非常多的跨进程通信机制，比如管道，System V，Socket等；为什么还需要单独搞一个Binder出来呢？**主要有两点，性能和安全**。在移动设备上，广泛地使用跨进程通信肯定对通信机制本身提出了严格的要求；Binder相对出传统的Socket方式，更加高效；另外，传统的进程通信方式对于通信双方的身份并没有做出严格的验证，只有在上层协议上进行架设；比如Socket通信ip地址是客户端手动填入的，都可以进行伪造；而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。这个也是Android权限模型的基础。
2. Binder的通信模型包含四个角色: **Client**, **Server**, **SM(Service Manager)**, **driver**

## 3. Binder 机制跨进程原理：

首先，Server进程要向SM注册；告诉自己是谁，自己有什么能力；在这个场景就是Server告诉SM，它叫`zhangsan`，它有一个`object`对象，可以执行`add`操作；于是SM建立了一张表：`zhangsan`这个名字对应进程`Server`;

然后Client向SM查询：我需要联系一个名字叫做`zhangsan`的进程里面的`object`对象；**这时候关键来了**：进程之间通信的数据都会经过运行在内核空间里面的驱动，驱动在数据流过的时候做了一点手脚，它并不会给Client进程返回一个真正的`object`对象，而是返回一个看起来跟`object`一模一样的代理对象`objectProxy`，这个`objectProxy`也有一个`add`方法，但是这个`add`方法没有Server进程里面`object`对象的`add`方法那个能力；`objectProxy`的`add`只是一个**傀儡**，它唯一做的事情就是把参数包装然后交给驱动。(这里我们简化了SM的流程，见下文)

但是Client进程并不知道驱动返回给它的对象动过手脚，毕竟伪装的太像了，如假包换。Client开开心心地拿着`objectProxy`对象然后调用add方法；我们说过，这个`add`什么也不做，直接把参数做一些包装然后直接转发给`Binder`驱动。

驱动收到这个消息，发现是这个`objectProxy`；一查表就明白了：我之前用`objectProxy`替换了`object`发送给Client了，它真正应该要访问的是`object`对象的`add`方法；于是Binder驱动通知Server进程，调用你的`object`对象的`add`方法，然后把结果发给我，Sever进程收到这个消息，照做之后将结果返回驱动，驱动然后把结果返回给Client进程；于是整个过程就完成了。

由于驱动返回的`objectProxy`与Server进程里面原始的`object`是如此相似，**给人感觉好像是直接把Server进程里面的对象`object`传递到了Client进程；因此，我们可以说Binder对象是可以进行跨进程传递的对象**

但事实上我们知道，Binder跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是Binder跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client进程的操作其实是对于影子的操作，影子利用Binder驱动最终让真身完成操作。

理解这一点非常重要；务必仔细体会。另外，Android系统实现这种机制使用的是代理模式, 对于Binder的访问，如果是在同一个进程（不需要跨进程），那么直接返回原始的Binder实体；如果在不同进程，那么就给他一个代理对象（影子）；我们在系统源码以及AIDL的生成代码里面可以看到很多这种实现。

另外我们为了简化整个流程，隐藏了SM这一部分驱动进行的操作；实际上，由于SM与Server通常不在一个进程，Server进程向SM注册的过程也是跨进程通信，驱动也会对这个过程进行暗箱操作：SM中存在的Server端的对象实际上也是代理对象，后面Client向SM查询的时候，驱动会给Client返回另外一个代理对象。Sever进程的本地对象仅有一个，其他进程所拥有的全部都是它的代理。

一句话总结就是：**Client进程只不过是持有了Server端的代理；代理对象协助驱动完成了跨进程通信**。

## 4. Binder到底是什么？

* 通常意义下，Binder指的是一种通信机制；我们说AIDL使用Binder进行通信，指的就是**Binder这种IPC机制**。
* 对于Server进程来说，Binder指的是**Binder本地对象**
* 对于Client来说，Binder指的是**Binder代理对象**，**它只是Binder本地对象的一个远程代理**；对这个Binder代理对象的操作，会通过驱动最终转发到Binder本地对象上去完成；对于一个拥有Binder对象的使用者而言，它无须关心这是一个Binder代理对象还是Binder本地对象；对于代理对象的操作和对本地对象的操作对它来说没有区别。
* 对于传输过程而言，Binder是可以进行跨进程传递的对象；**Binder驱动会对具有跨进程传递能力的对象做特殊处理：自动完成代理对象和本地对象的转换**。
* Server进程里面的Binder对象指的是Binder本地对象，Client里面的对象值得是Binder代理对象；**在Binder对象进行跨进程传递的时候，Binder驱动会自动完成这两种类型的转换**；因此Binder驱动必然保存了每一个跨越进程的Binder对象的相关信息；在驱动中，Binder本地对象的代表是一个叫做`binder_node`的数据结构，Binder代理对象是用`binder_ref`代表的。

## 5. 深入理解Java层的Binder

**IBinder/IInterface/Binder/BinderProxy/Stub**

* **IBinder是一个接口，它代表了一种跨进程传输的能力**；只要实现了这个接口，就能将这个对象进行跨进程传递；这是驱动底层支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。
* IBinder负责数据传输，那么client与server端的调用契约（这里不用接口避免混淆）呢？这里的**IInterface代表的就是远程server对象具有什么能力**。具体来说，就是aidl里面的接口。
* Java层的Binder类，代表的其实就是**Binder本地对象**。BinderProxy类是Binder类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder驱动会自动完成这两个对象的转换。
* 在使用AIDL的时候，编译工具会给我们生成一个**Stub的静态内部类**；这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成，这里使用了策略模式。

## 6. AIDL 过程分析




---
[参考文献]
* [Binder学习指南](http://weishu.me/2016/01/12/binder-index-for-newer/)